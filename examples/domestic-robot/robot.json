[
  {
    "timestamp": 1694697127003,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__1",
          "trigger": "has(owner,beer)",
          "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
          "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
        }
      },
      "log": "Plan has(owner,beer)(available(beer,fridge) \u0026 not (too_much(beer))) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127013,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__2",
          "trigger": "has(owner,beer)",
          "context": "not (available(beer,fridge))",
          "body": ".send(supermarket,achieve,order(beer,5)); !at(robot,fridge)"
        }
      },
      "log": "Plan has(owner,beer)not (available(beer,fridge)) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127017,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__3",
          "trigger": "has(owner,beer)",
          "context": "(too_much(beer) \u0026 limit(beer,L))",
          "body": ".concat(\"The Department of Health does not allow me to give you more than \",L,\" beers a day! I am very sorry about that!\",M); .send(owner,tell,msg(M))"
        }
      },
      "log": "Plan has(owner,beer)(too_much(beer) \u0026 limit(beer,L)) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127021,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__4",
          "trigger": "has(_4,_5)",
          "context": "",
          "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
        }
      },
      "log": "Plan has(_4,_5) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127024,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__5",
          "trigger": "at(robot,P)",
          "context": "at(robot,P)",
          "body": ""
        }
      },
      "log": "Plan at(robot,P)at(robot,P) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127026,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan at(robot,P)not (at(robot,P)) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127032,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__7",
          "trigger": "delivered(beer,_6_Qtd,_7_OrderId)[source(supermarket)]",
          "context": "",
          "body": "+available(beer,fridge); !has(owner,beer)"
        }
      },
      "log": "Plan delivered(beer,_6_Qtd,_7_OrderId)[source(supermarket)] added to the plan library"
    }
  },
  {
    "timestamp": 1694697127035,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__8",
          "trigger": "stock(beer,0)",
          "context": "available(beer,fridge)",
          "body": "-available(beer,fridge)"
        }
      },
      "log": "Plan stock(beer,0)available(beer,fridge) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127037,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__9",
          "trigger": "stock(beer,N)",
          "context": "((N \u003e 0) \u0026 not (available(beer,fridge)))",
          "body": "-+available(beer,fridge)"
        }
      },
      "log": "Plan stock(beer,N)((N \u003e 0) \u0026 not (available(beer,fridge))) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127042,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "p__10",
          "trigger": "time(T)",
          "context": "",
          "body": "time.check(T)"
        }
      },
      "log": "Plan time(T) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127054,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "limit(beer,10)",
          "functor": "limit",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "self"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "10"
            ]
          }
        }
      },
      "log": "Added belief limit(beer,10) from source: [self]"
    }
  },
  {
    "timestamp": 1694697127056,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "limit(beer,10)",
          "functor": "limit",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "self"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "10"
            ]
          }
        }
      },
      "log": "Added belief limit(beer,10)"
    }
  },
  {
    "timestamp": 1694697127060,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "available(beer,fridge)",
          "functor": "available",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "self"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "fridge"
            ]
          }
        }
      },
      "log": "Added belief available(beer,fridge) from source: [self]"
    }
  },
  {
    "timestamp": 1694697127062,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "available(beer,fridge)",
          "functor": "available",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "self"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "fridge"
            ]
          }
        }
      },
      "log": "Added belief available(beer,fridge)"
    }
  },
  {
    "timestamp": 1694697127071,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedTellStructure",
          "trigger": "kqml_received(Sender,tell,NS::Content,_8)",
          "context": "(.literal(Content) \u0026 (.ground(Content) \u0026 (not (.list(Content)) \u0026 .add_nested_source(Content,Sender,CA))))",
          "body": "++NS::CA"
        }
      },
      "log": "Plan kqml_received(Sender,tell,NS::Content,_8)(.literal(Content) \u0026 (.ground(Content) \u0026 (not (.list(Content)) \u0026 .add_nested_source(Content,Sender,CA)))) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127073,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedTellList",
          "trigger": "kqml_received(Sender,tell,Content,_9)",
          "context": ".list(Content)",
          "body": "!add_all_kqml_received(Sender,Content)"
        }
      },
      "log": "Plan kqml_received(Sender,tell,Content,_9).list(Content) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127075,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedTellList1",
          "trigger": "add_all_kqml_received(_10,[])",
          "context": "",
          "body": ""
        }
      },
      "log": "Plan add_all_kqml_received(_10,[]) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127077,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedTellList2",
          "trigger": "add_all_kqml_received(Sender,[NS::H|T])",
          "context": "(.literal(H) \u0026 .ground(H))",
          "body": ".add_nested_source(H,Sender,CA); ++NS::CA; !add_all_kqml_received(Sender,T)"
        }
      },
      "log": "Plan add_all_kqml_received(Sender,[NS::H|T])(.literal(H) \u0026 .ground(H)) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127080,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedTellList3",
          "trigger": "add_all_kqml_received(Sender,[_11|T])",
          "context": "",
          "body": "!add_all_kqml_received(Sender,T)"
        }
      },
      "log": "Plan add_all_kqml_received(Sender,[_11|T]) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127083,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedUnTell",
          "trigger": "kqml_received(Sender,untell,NS::Content,_12)",
          "context": ".add_nested_source(Content,Sender,CA)",
          "body": "--NS::CA"
        }
      },
      "log": "Plan kqml_received(Sender,untell,NS::Content,_12).add_nested_source(Content,Sender,CA) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127085,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAchieve",
          "trigger": "kqml_received(Sender,achieve,NS::Content,_13)",
          "context": "(not (.list(Content)) \u0026 .add_nested_source(Content,Sender,CA))",
          "body": "!!NS::CA"
        }
      },
      "log": "Plan kqml_received(Sender,achieve,NS::Content,_13)(not (.list(Content)) \u0026 .add_nested_source(Content,Sender,CA)) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127087,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAchieveList",
          "trigger": "kqml_received(Sender,achieve,Content,_14)",
          "context": ".list(Content)",
          "body": "!add_all_kqml_achieve(Sender,Content)"
        }
      },
      "log": "Plan kqml_received(Sender,achieve,Content,_14).list(Content) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127089,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAchieveList1",
          "trigger": "add_all_kqml_achieve(_15,[])",
          "context": "",
          "body": ""
        }
      },
      "log": "Plan add_all_kqml_achieve(_15,[]) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127091,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAchieveList2",
          "trigger": "add_all_kqml_achieve(Sender,[NS::H|T])",
          "context": "",
          "body": ".add_nested_source(H,Sender,CA); !!NS::CA; !add_all_kqml_achieve(Sender,T)"
        }
      },
      "log": "Plan add_all_kqml_achieve(Sender,[NS::H|T]) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127095,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedUnAchieve",
          "trigger": "kqml_received(_16,unachieve,NS::Content,_17)",
          "context": "",
          "body": ".drop_desire(NS::Content)"
        }
      },
      "log": "Plan kqml_received(_16,unachieve,NS::Content,_17) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127097,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAskOne1d",
          "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
          "context": "kqml::bel_no_source_self(NS,Content,Ans)",
          "body": ".send(Sender,tell,NS::Ans,MsgId)"
        }
      },
      "log": "Plan kqml_received(Sender,askOne,NS::Content,MsgId)kqml::bel_no_source_self(NS,Content,Ans) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127100,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAskOne1c",
          "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
          "context": "",
          "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
        }
      },
      "log": "Plan kqml_received(Sender,askOne,NS::Content,MsgId) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127104,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAskOne2",
          "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)[error(test_goal_failed)]",
          "context": "",
          "body": ".send(Sender,untell,NS::Content,MsgId)"
        }
      },
      "log": "Plan kqml_received(Sender,askOne,NS::Content,MsgId)[error(test_goal_failed)] added to the plan library"
    }
  },
  {
    "timestamp": 1694697127110,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAskAll2",
          "trigger": "kqml_received(Sender,askAll,NS::Content,MsgId)",
          "context": "",
          "body": ".findall(NS::Ans,kqml::bel_no_source_self(NS,Content,Ans),List); .send(Sender,tell,List,MsgId)"
        }
      },
      "log": "Plan kqml_received(Sender,askAll,NS::Content,MsgId) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127115,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedTellHow",
          "trigger": "kqml_received(Sender,tellHow,Content,_19)",
          "context": "",
          "body": ".remove_source_annot(Content,ContentAn); .add_plan(ContentAn,Sender)"
        }
      },
      "log": "Plan kqml_received(Sender,tellHow,Content,_19) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127120,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedUnTellHow",
          "trigger": "kqml_received(Sender,untellHow,Content,_20)",
          "context": "",
          "body": ".remove_plan(Content,Sender)"
        }
      },
      "log": "Plan kqml_received(Sender,untellHow,Content,_20) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127125,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedAskHow",
          "trigger": "kqml_received(Sender,askHow,Content,MsgId)",
          "context": "",
          "body": ".relevant_plans(Content,ListOfPlans); .remove_source_annot(ListOfPlans,ListOfPlansAn); .send(Sender,tellHow,ListOfPlansAn,MsgId)"
        }
      },
      "log": "Plan kqml_received(Sender,askHow,Content,MsgId) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127130,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlReceivedSignal",
          "trigger": "kqml_received(Sender,signal,NS::Content,_21)",
          "context": "(not (.list(Content)) \u0026 .add_nested_source(Content,Sender,CA))",
          "body": ".signal({ +NS::CA },type_signal)"
        }
      },
      "log": "Plan kqml_received(Sender,signal,NS::Content,_21)(not (.list(Content)) \u0026 .add_nested_source(Content,Sender,CA)) added to the plan library"
    }
  },
  {
    "timestamp": 1694697127133,
    "message": {
      "type": "PlanAdded",
      "event": {
        "planInfo": {
          "label": "kqmlError",
          "trigger": "kqml_received(_22_Sender,_23_Per,_24_Content,_25_MsgId)[error(EID),error_msg(EMsg)]",
          "context": "",
          "body": ".print(\"Communication error -- \",EID,\": \",EMsg)"
        }
      },
      "log": "Plan kqml_received(_22_Sender,_23_Per,_24_Content,_25_MsgId)[error(EID),error_msg(EMsg)] added to the plan library"
    }
  },
  {
    "timestamp": 1694697127137,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "kqml::clear_source_self([],[])",
          "functor": "clear_source_self",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "self"
            ]
          },
          "terms": {
            "value": [
              "[]",
              "[]"
            ]
          }
        }
      },
      "log": "Added belief kqml::clear_source_self([],[]) from source: [self]"
    }
  },
  {
    "timestamp": 1694697127139,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "kqml::clear_source_self([],[])",
          "functor": "clear_source_self",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "self"
            ]
          },
          "terms": {
            "value": [
              "[]",
              "[]"
            ]
          }
        }
      },
      "log": "Added belief kqml::clear_source_self([],[])"
    }
  },
  {
    "timestamp": 1694697127357,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 1
      },
      "log": "New reasoning cycle started: 1"
    }
  },
  {
    "timestamp": 1694697127411,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 2
      },
      "log": "New reasoning cycle started: 2"
    }
  },
  {
    "timestamp": 1694697127421,
    "message": {
      "type": "MailBoxMessages",
      "event": {
        "messages": [
          {
            "id": "mid1",
            "type": "achieve",
            "sender": "owner",
            "receiver": "robot",
            "message": "has(owner,beer)"
          }
        ]
      },
      "log": "Messages in mailbox: \n\tachieve message from owner: has(owner,beer)"
    }
  },
  {
    "timestamp": 1694697127428,
    "message": {
      "type": "SelectedMessage",
      "event": {
        "selected": {
          "id": "mid1",
          "type": "achieve",
          "sender": "owner",
          "receiver": "robot",
          "message": "has(owner,beer)"
        }
      },
      "log": "Selected Message: has(owner,beer)"
    }
  },
  {
    "timestamp": 1694697127435,
    "message": {
      "type": "NewSpeechActMessage",
      "event": {
        "message": {
          "id": "mid1",
          "type": "achieve",
          "sender": "owner",
          "receiver": "robot",
          "message": "has(owner,beer)"
        }
      },
      "log": "New speech act message [achieve] from owner: has(owner,beer)"
    }
  },
  {
    "timestamp": 1694697127443,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal has(owner,beer) created"
    }
  },
  {
    "timestamp": 1694697127486,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "has(owner,beer)[source(owner)]",
        "planOptions": [
          {
            "label": "p__1",
            "trigger": "has(owner,beer)",
            "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
            "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
          }
        ],
        "selectedPlan": {
          "label": "p__1",
          "trigger": "has(owner,beer)",
          "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
          "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
        }
      },
      "log": "Plan options for has(owner,beer)[source(owner)] are: \n\thas(owner,beer) : (available(beer,fridge) \u0026 not (too_much(beer))) \u003c- !at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer).\nThe plan selected for has(owner,beer)[source(owner)] is \thas(owner,beer) : (available(beer,fridge) \u0026 not (too_much(beer))) \u003c- !at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)."
    }
  },
  {
    "timestamp": 1694697127493,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127499,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: undefined\n\tcurrent step: !at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697127509,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) (sub-goal of has) created"
    }
  },
  {
    "timestamp": 1694697127516,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,fridge)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:20"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,fridge) of type achieve executed - from file:src/agt/robot.asl:20"
    }
  },
  {
    "timestamp": 1694697127520,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 3
      },
      "log": "New reasoning cycle started: 3"
    }
  },
  {
    "timestamp": 1694697127523,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,fridge)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,fridge)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,fridge)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697127527,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127533,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: undefined\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127540,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(fridge))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(fridge), state: undefined\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127548,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(fridge)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(fridge) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697127553,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697127703,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 4
      },
      "log": "New reasoning cycle started: 4"
    }
  },
  {
    "timestamp": 1694697127706,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: undefined\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127710,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127713,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127717,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697127723,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697127726,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 5
      },
      "log": "New reasoning cycle started: 5"
    }
  },
  {
    "timestamp": 1694697127729,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,fridge)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,fridge)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,fridge)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697127734,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127739,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697127742,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: undefined\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127746,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(fridge))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(fridge), state: undefined\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127750,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(fridge)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(fridge) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697127754,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697127908,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 6
      },
      "log": "New reasoning cycle started: 6"
    }
  },
  {
    "timestamp": 1694697127923,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 7
      },
      "log": "New reasoning cycle started: 7"
    }
  },
  {
    "timestamp": 1694697127926,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: undefined\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127928,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127931,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127934,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697127938,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697127941,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 8
      },
      "log": "New reasoning cycle started: 8"
    }
  },
  {
    "timestamp": 1694697127945,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,fridge)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,fridge)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,fridge)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697127950,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697127954,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697127959,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: undefined\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127963,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(fridge))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(fridge), state: undefined\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697127968,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(fridge)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(fridge) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697127975,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697128130,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 9
      },
      "log": "New reasoning cycle started: 9"
    }
  },
  {
    "timestamp": 1694697128134,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "at(robot,fridge)",
          "functor": "at",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "robot",
              "fridge"
            ]
          }
        }
      },
      "log": "Added belief at(robot,fridge) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697128137,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "at(robot,fridge)",
          "functor": "at",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "robot",
              "fridge"
            ]
          }
        }
      },
      "log": "Added belief at(robot,fridge)"
    }
  },
  {
    "timestamp": 1694697128144,
    "message": {
      "type": "NewPercept",
      "event": {
        "perceptInfo": {
          "functor": "at(robot,fridge)",
          "artifactId": "",
          "artifactName": "",
          "perceptType": ""
        }
      },
      "log": "New  percept from : at(robot,fridge)"
    }
  },
  {
    "timestamp": 1694697128149,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697128154,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128159,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128165,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697128170,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003dfridge}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697128175,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 10
      },
      "log": "New reasoning cycle started: 10"
    }
  },
  {
    "timestamp": 1694697128181,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,fridge)[source(self)]",
        "planOptions": [
          {
            "label": "p__5",
            "trigger": "at(robot,P)",
            "context": "at(robot,P)",
            "body": ""
          }
        ],
        "selectedPlan": {
          "label": "p__5",
          "trigger": "at(robot,P)",
          "context": "at(robot,P)",
          "body": ""
        }
      },
      "log": "Plan options for at(robot,fridge)[source(self)] are: \n\tat(robot,P) : at(robot,P).\nThe plan selected for at(robot,fridge)[source(self)] is \tat(robot,P) : at(robot,P)."
    }
  },
  {
    "timestamp": 1694697128188,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,fridge) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128194,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003dfridge}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697128200,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__5",
                "trigger": "at(robot,P)",
                "context": "at(robot,P)",
                "body": ""
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": ""
              },
              "isFinished": true
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697128206,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__5",
                "trigger": "at(robot,P)",
                "context": "at(robot,P)",
                "body": ""
              },
              "unifier": "{P\u003dfridge}",
              "currentStep": {
                "value": ""
              },
              "isFinished": true
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697128211,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,fridge)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,fridge) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697128217,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 11
      },
      "log": "New reasoning cycle started: 11"
    }
  },
  {
    "timestamp": 1694697128223,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(open(fridge))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "open(fridge)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 has waiting to execute action open(fridge), state: waiting\n\tcurrent step: open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697128230,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "open(fridge)",
          "source": "file:src/agt/robot.asl:21",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action open(fridge) from file:src/agt/robot.asl:21"
    }
  },
  {
    "timestamp": 1694697128237,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "open(fridge)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:21"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action open(fridge) finished"
    }
  },
  {
    "timestamp": 1694697128292,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 12
      },
      "log": "New reasoning cycle started: 12"
    }
  },
  {
    "timestamp": 1694697128297,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,2)",
          "functor": "stock",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "2"
            ]
          }
        }
      },
      "log": "Added belief stock(beer,2) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697128302,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,2)",
          "functor": "stock",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "2"
            ]
          }
        }
      },
      "log": "Added belief stock(beer,2)"
    }
  },
  {
    "timestamp": 1694697128309,
    "message": {
      "type": "NewPercept",
      "event": {
        "perceptInfo": {
          "functor": "stock(beer,2)",
          "artifactId": "",
          "artifactName": "",
          "perceptType": ""
        }
      },
      "log": "New  percept from : stock(beer,2)"
    }
  },
  {
    "timestamp": 1694697128333,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 13
      },
      "log": "New reasoning cycle started: 13"
    }
  },
  {
    "timestamp": 1694697128339,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: waiting\n\tcurrent step: get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697128346,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(open(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "open(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128352,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(get(beer))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "get(beer)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 has waiting to execute action get(beer), state: waiting\n\tcurrent step: get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697128360,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "get(beer)",
          "source": "file:src/agt/robot.asl:22",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action get(beer) from file:src/agt/robot.asl:22"
    }
  },
  {
    "timestamp": 1694697128365,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "get(beer)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:22"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action get(beer) finished"
    }
  },
  {
    "timestamp": 1694697128481,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 14
      },
      "log": "New reasoning cycle started: 14"
    }
  },
  {
    "timestamp": 1694697128488,
    "message": {
      "type": "BeliefFromSrcRemoved",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,2)",
          "functor": "stock",
          "operator": "-",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "2"
            ]
          }
        }
      },
      "log": "Removed belief stock(beer,2) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697128494,
    "message": {
      "type": "BeliefRemoved",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,2)",
          "functor": "stock",
          "operator": "-",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "2"
            ]
          }
        }
      },
      "log": "Removed belief stock(beer,2)"
    }
  },
  {
    "timestamp": 1694697128502,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,1)",
          "functor": "stock",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "1"
            ]
          }
        }
      },
      "log": "Added belief stock(beer,1) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697128507,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,1)",
          "functor": "stock",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "1"
            ]
          }
        }
      },
      "log": "Added belief stock(beer,1)"
    }
  },
  {
    "timestamp": 1694697128512,
    "message": {
      "type": "NewPercept",
      "event": {
        "perceptInfo": {
          "functor": "stock(beer,1)",
          "artifactId": "",
          "artifactName": "",
          "perceptType": ""
        }
      },
      "log": "New  percept from : stock(beer,1)"
    }
  },
  {
    "timestamp": 1694697128518,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: waiting\n\tcurrent step: close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697128524,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(get(beer))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "get(beer)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128530,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(close(fridge))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "close(fridge)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 has waiting to execute action close(fridge), state: waiting\n\tcurrent step: close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697128537,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "close(fridge)",
          "source": "file:src/agt/robot.asl:23",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action close(fridge) from file:src/agt/robot.asl:23"
    }
  },
  {
    "timestamp": 1694697128543,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "close(fridge)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:23"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action close(fridge) finished"
    }
  },
  {
    "timestamp": 1694697128637,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 15
      },
      "log": "New reasoning cycle started: 15"
    }
  },
  {
    "timestamp": 1694697128644,
    "message": {
      "type": "BeliefFromSrcRemoved",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,1)",
          "functor": "stock",
          "operator": "-",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "1"
            ]
          }
        }
      },
      "log": "Removed belief stock(beer,1) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697128650,
    "message": {
      "type": "BeliefRemoved",
      "event": {
        "beliefInfo": {
          "literal": "stock(beer,1)",
          "functor": "stock",
          "operator": "-",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "beer",
              "1"
            ]
          }
        }
      },
      "log": "Removed belief stock(beer,1)"
    }
  },
  {
    "timestamp": 1694697128655,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: waiting\n\tcurrent step: !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
    }
  },
  {
    "timestamp": 1694697128662,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(close(fridge))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "close(fridge)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128668,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of has) created"
    }
  },
  {
    "timestamp": 1694697128674,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,owner)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:24"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,owner) of type achieve executed - from file:src/agt/robot.asl:24"
    }
  },
  {
    "timestamp": 1694697128680,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 16
      },
      "log": "New reasoning cycle started: 16"
    }
  },
  {
    "timestamp": 1694697128686,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697128693,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128699,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697128707,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(owner))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(owner), state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697128719,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(owner)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(owner) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697128726,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697128882,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 17
      },
      "log": "New reasoning cycle started: 17"
    }
  },
  {
    "timestamp": 1694697128889,
    "message": {
      "type": "BeliefFromSrcRemoved",
      "event": {
        "beliefInfo": {
          "literal": "at(robot,fridge)",
          "functor": "at",
          "operator": "-",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "robot",
              "fridge"
            ]
          }
        }
      },
      "log": "Removed belief at(robot,fridge) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697128895,
    "message": {
      "type": "BeliefRemoved",
      "event": {
        "beliefInfo": {
          "literal": "at(robot,fridge)",
          "functor": "at",
          "operator": "-",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "robot",
              "fridge"
            ]
          }
        }
      },
      "log": "Removed belief at(robot,fridge)"
    }
  },
  {
    "timestamp": 1694697128902,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697128909,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128916,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128923,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697128931,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697128937,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 18
      },
      "log": "New reasoning cycle started: 18"
    }
  },
  {
    "timestamp": 1694697128943,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697128950,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697128957,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697128964,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697128971,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(owner))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(owner), state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697128978,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(owner)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(owner) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697128985,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697129041,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 19
      },
      "log": "New reasoning cycle started: 19"
    }
  },
  {
    "timestamp": 1694697129148,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 20
      },
      "log": "New reasoning cycle started: 20"
    }
  },
  {
    "timestamp": 1694697129154,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129160,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129167,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129173,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697129179,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697129185,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 21
      },
      "log": "New reasoning cycle started: 21"
    }
  },
  {
    "timestamp": 1694697129192,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697129199,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129206,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697129212,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129219,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(owner))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(owner), state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129226,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(owner)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(owner) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697129234,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697129391,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 22
      },
      "log": "New reasoning cycle started: 22"
    }
  },
  {
    "timestamp": 1694697129399,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129407,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129414,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129421,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697129428,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697129435,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 23
      },
      "log": "New reasoning cycle started: 23"
    }
  },
  {
    "timestamp": 1694697129443,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697129450,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129457,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697129463,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129471,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(owner))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(owner), state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129478,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(owner)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(owner) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697129485,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697129642,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 24
      },
      "log": "New reasoning cycle started: 24"
    }
  },
  {
    "timestamp": 1694697129649,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129654,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129660,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129667,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697129672,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697129678,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 25
      },
      "log": "New reasoning cycle started: 25"
    }
  },
  {
    "timestamp": 1694697129683,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697129690,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129696,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697129702,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129708,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(owner))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(owner), state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129714,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(owner)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(owner) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697129720,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697129779,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 26
      },
      "log": "New reasoning cycle started: 26"
    }
  },
  {
    "timestamp": 1694697129864,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 27
      },
      "log": "New reasoning cycle started: 27"
    }
  },
  {
    "timestamp": 1694697129873,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129879,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129884,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129890,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697129895,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697129900,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 28
      },
      "log": "New reasoning cycle started: 28"
    }
  },
  {
    "timestamp": 1694697129906,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__6",
            "trigger": "at(robot,P)",
            "context": "not (at(robot,P))",
            "body": "move_towards(P); !at(robot,P)"
          }
        ],
        "selectedPlan": {
          "label": "p__6",
          "trigger": "at(robot,P)",
          "context": "not (at(robot,P))",
          "body": "move_towards(P); !at(robot,P)"
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : not (at(robot,P)) \u003c- move_towards(P); !at(robot,P)."
    }
  },
  {
    "timestamp": 1694697129912,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697129917,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697129922,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129928,
    "message": {
      "type": "IntentionWaiting",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": {
            "reason": "action(move towards(owner))",
            "functor": {
              "value": "action"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Intention 3 at waiting to execute action move_towards(owner), state: waiting\n\tcurrent step: move_towards(P); !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697129934,
    "message": {
      "type": "ExternalActionTriggered",
      "event": {
        "action": {
          "term": "move_towards(owner)",
          "source": "file:src/agt/robot.asl:49",
          "intention": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        },
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "move_towards(P); !at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        }
      },
      "log": "Execute action move_towards(owner) from file:src/agt/robot.asl:49"
    }
  },
  {
    "timestamp": 1694697129939,
    "message": {
      "type": "ExternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "move_towards(P)",
          "type": "action",
          "srcInfo": "file:src/agt/robot.asl:49"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "move_towards(P); !at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Action move_towards(P) finished"
    }
  },
  {
    "timestamp": 1694697130076,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 29
      },
      "log": "New reasoning cycle started: 29"
    }
  },
  {
    "timestamp": 1694697130087,
    "message": {
      "type": "BeliefFromSrcAdded",
      "event": {
        "beliefInfo": {
          "literal": "at(robot,owner)",
          "functor": "at",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "robot",
              "owner"
            ]
          }
        }
      },
      "log": "Added belief at(robot,owner) from source: [percept]"
    }
  },
  {
    "timestamp": 1694697130093,
    "message": {
      "type": "BeliefAdded",
      "event": {
        "beliefInfo": {
          "literal": "at(robot,owner)",
          "functor": "at",
          "operator": "+",
          "perceptType": {
            "value": null
          },
          "source": {
            "value": [
              "percept"
            ]
          },
          "terms": {
            "value": [
              "robot",
              "owner"
            ]
          }
        }
      },
      "log": "Added belief at(robot,owner)"
    }
  },
  {
    "timestamp": 1694697130100,
    "message": {
      "type": "NewPercept",
      "event": {
        "perceptInfo": {
          "functor": "at(robot,owner)",
          "artifactId": "",
          "artifactName": "",
          "perceptType": ""
        }
      },
      "log": "New  percept from : at(robot,owner)"
    }
  },
  {
    "timestamp": 1694697130108,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__6",
                "trigger": "at(robot,P)",
                "context": "not (at(robot,P))",
                "body": "move_towards(P); !at(robot,P)"
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": "!at(robot,P)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: !at(robot,P)"
    }
  },
  {
    "timestamp": 1694697130117,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697130129,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "action executed(move towards(owner))",
            "functor": {
              "value": "action_executed"
            },
            "terms": {
              "value": [
                "move_towards(owner)"
              ]
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697130137,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) (sub-goal of at) created"
    }
  },
  {
    "timestamp": 1694697130145,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "at(robot,P)",
          "type": "achieve",
          "srcInfo": "file:src/agt/robot.asl:50"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "at",
                "type": "achieve",
                "plan": {
                  "label": "p__6",
                  "trigger": "at(robot,P)",
                  "context": "not (at(robot,P))",
                  "body": "move_towards(P); !at(robot,P)"
                },
                "unifier": "{P\u003downer}",
                "currentStep": {
                  "value": "!at(robot,P)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed at(robot,P) of type achieve executed - from file:src/agt/robot.asl:50"
    }
  },
  {
    "timestamp": 1694697130150,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 30
      },
      "log": "New reasoning cycle started: 30"
    }
  },
  {
    "timestamp": 1694697130155,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "at(robot,owner)[source(self)]",
        "planOptions": [
          {
            "label": "p__5",
            "trigger": "at(robot,P)",
            "context": "at(robot,P)",
            "body": ""
          }
        ],
        "selectedPlan": {
          "label": "p__5",
          "trigger": "at(robot,P)",
          "context": "at(robot,P)",
          "body": ""
        }
      },
      "log": "Plan options for at(robot,owner)[source(self)] are: \n\tat(robot,P) : at(robot,P).\nThe plan selected for at(robot,owner)[source(self)] is \tat(robot,P) : at(robot,P)."
    }
  },
  {
    "timestamp": 1694697130160,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan at(robot,owner) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697130165,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "at",
                  "type": "achieve",
                  "plan": {
                    "label": "p__6",
                    "trigger": "at(robot,P)",
                    "context": "not (at(robot,P))",
                    "body": "move_towards(P); !at(robot,P)"
                  },
                  "unifier": "{P\u003downer}",
                  "currentStep": {
                    "value": "!at(robot,P)"
                  },
                  "isFinished": false
                },
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697130169,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__5",
                "trigger": "at(robot,P)",
                "context": "at(robot,P)",
                "body": ""
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": ""
              },
              "isFinished": true
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697130174,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "at",
              "type": "achieve",
              "plan": {
                "label": "p__5",
                "trigger": "at(robot,P)",
                "context": "at(robot,P)",
                "body": ""
              },
              "unifier": "{P\u003downer}",
              "currentStep": {
                "value": ""
              },
              "isFinished": true
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 at created, state: waiting\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697130180,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "at(robot,owner)",
          "source": {
            "value": [
              "self"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "!at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal at(robot,owner) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697130185,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 31
      },
      "log": "New reasoning cycle started: 31"
    }
  },
  {
    "timestamp": 1694697130191,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "failed",
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal has(owner,beer) removed because the goal is failed"
    }
  },
  {
    "timestamp": 1694697130198,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": {
            "reason": "has failure plan",
            "functor": {
              "value": "has_failure_plan"
            },
            "terms": {
              "value": null
            }
          }
        }
      },
      "log": "Plan has(owner,beer) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697130213,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "has(owner,beer)",
          "type": "test",
          "srcInfo": "file:src/agt/robot.asl:26"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed has(owner,beer) of type test executed - from file:src/agt/robot.asl:26"
    }
  },
  {
    "timestamp": 1694697130225,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 32
      },
      "log": "New reasoning cycle started: 32"
    }
  },
  {
    "timestamp": 1694697130231,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "has(owner,beer)[code(has(owner,beer)),code_line(26),code_src(\"file:src/agt/robot.asl\"),error(test_goal_failed),error_msg(\"Failed to test \u0027has(owner,beer)\u0027\"),source(owner)]",
        "planOptions": [
          {
            "label": "p__4",
            "trigger": "has(_4,_5)",
            "context": "",
            "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
          }
        ],
        "selectedPlan": {
          "label": "p__4",
          "trigger": "has(_4,_5)",
          "context": "",
          "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
        }
      },
      "log": "Plan options for has(owner,beer)[code(has(owner,beer)),code_line(26),code_src(\"file:src/agt/robot.asl\"),error(test_goal_failed),error_msg(\"Failed to test \u0027has(owner,beer)\u0027\"),source(owner)] are: \n\thas(_4,_5) \u003c- .current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I).\nThe plan selected for has(owner,beer)[code(has(owner,beer)),code_line(26),code_src(\"file:src/agt/robot.asl\"),error(test_goal_failed),error_msg(\"Failed to test \u0027has(owner,beer)\u0027\"),source(owner)] is \thas(_4,_5) \u003c- .current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)."
    }
  },
  {
    "timestamp": 1694697130236,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__4",
                "trigger": "has(_4,_5)",
                "context": "",
                "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
              },
              "unifier": "{_4\u003downer, _5\u003dbeer}",
              "currentStep": {
                "value": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: waiting\n\tcurrent step: .current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
    }
  },
  {
    "timestamp": 1694697130250,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__4",
                "trigger": "has(_4,_5)",
                "context": "",
                "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
              },
              "unifier": "{_4\u003downer, _5\u003dbeer, I\u003dintention(3,[im(p__4[code_line(43),code_src(\"file:src/agt/robot.asl\"),source(self),url(\"file:src/agt/robot.asl\")],{ -!has(owner,beer)[code(has(owner,beer)),code_line(26),code_src(\"file:src/agt/robot.asl\"),error(test_goal_failed),error_msg(\"Failed to test \u0027has(owner,beer)\u0027\"),source(owner)] },{ .current_intention(_63); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",_63) },[map(_64_4,owner),map(_65_5,beer)]),im(p__1[code_line(19),code_src(\"file:src/agt/robot.asl\"),source(self),url(\"file:src/agt/robot.asl\")],{ +!has(owner,beer)[source(owner)] },{ ?has(owner,beer); .date(_66,_67,_68); .time(_69,_70,_71); +consumed(_66,_67,_68,_69,_70,_71,beer) },[])])}",
              "currentStep": {
                "value": ".print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
              },
              "isFinished": false
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: waiting\n\tcurrent step: .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
    }
  },
  {
    "timestamp": 1694697130258,
    "message": {
      "type": "InternalActionFinished",
      "event": {
        "deedInfo": {
          "term": ".current_intention(I)",
          "type": "internalAction",
          "srcInfo": "file:src/agt/robot.asl:44"
        },
        "intentionInfo": {
          "value": {
            "id": 3,
            "state": "waiting",
            "intendedMeansInfo": [
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__4",
                  "trigger": "has(_4,_5)",
                  "context": "",
                  "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
                },
                "unifier": "{_4\u003downer, _5\u003dbeer, I\u003dintention(3,[im(p__4[code_line(43),code_src(\"file:src/agt/robot.asl\"),source(self),url(\"file:src/agt/robot.asl\")],{ -!has(owner,beer)[code(has(owner,beer)),code_line(26),code_src(\"file:src/agt/robot.asl\"),error(test_goal_failed),error_msg(\"Failed to test \u0027has(owner,beer)\u0027\"),source(owner)] },{ .current_intention(_63); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",_63) },[map(_64_4,owner),map(_65_5,beer)]),im(p__1[code_line(19),code_src(\"file:src/agt/robot.asl\"),source(self),url(\"file:src/agt/robot.asl\")],{ +!has(owner,beer)[source(owner)] },{ ?has(owner,beer); .date(_66,_67,_68); .time(_69,_70,_71); +consumed(_66,_67,_68,_69,_70,_71,beer) },[])])}",
                "currentStep": {
                  "value": ".print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
                },
                "isFinished": false
              },
              {
                "trigger": "has",
                "type": "achieve",
                "plan": {
                  "label": "p__1",
                  "trigger": "has(owner,beer)",
                  "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                  "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "unifier": "{}",
                "currentStep": {
                  "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Internal action .current_intention(I) finished"
    }
  },
  {
    "timestamp": 1694697130266,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 33
      },
      "log": "New reasoning cycle started: 33"
    }
  },
  {
    "timestamp": 1694697130276,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": [
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__4",
                "trigger": "has(_4,_5)",
                "context": "",
                "body": ".current_intention(I); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)"
              },
              "unifier": "{_4\u003downer, _5\u003dbeer, I\u003dintention(3,[im(p__4[code_line(43),code_src(\"file:src/agt/robot.asl\"),source(self),url(\"file:src/agt/robot.asl\")],{ -!has(owner,beer)[code(has(owner,beer)),code_line(26),code_src(\"file:src/agt/robot.asl\"),error(test_goal_failed),error_msg(\"Failed to test \u0027has(owner,beer)\u0027\"),source(owner)] },{ .current_intention(_63); .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",_63) },[map(_64_4,owner),map(_65_5,beer)]),im(p__1[code_line(19),code_src(\"file:src/agt/robot.asl\"),source(self),url(\"file:src/agt/robot.asl\")],{ +!has(owner,beer)[source(owner)] },{ ?has(owner,beer); .date(_66,_67,_68); .time(_69,_70,_71); +consumed(_66,_67,_68,_69,_70,_71,beer) },[])])}",
              "currentStep": {
                "value": null
              },
              "isFinished": true
            },
            {
              "trigger": "has",
              "type": "achieve",
              "plan": {
                "label": "p__1",
                "trigger": "has(owner,beer)",
                "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "unifier": "{}",
              "currentStep": {
                "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 has created, state: waiting\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697130284,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "has(owner,beer)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": {
              "id": 3,
              "state": "waiting",
              "intendedMeansInfo": [
                {
                  "trigger": "has",
                  "type": "achieve",
                  "plan": {
                    "label": "p__1",
                    "trigger": "has(owner,beer)",
                    "context": "(available(beer,fridge) \u0026 not (too_much(beer)))",
                    "body": "!at(robot,fridge); open(fridge); get(beer); close(fridge); !at(robot,owner); ?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "unifier": "{}",
                  "currentStep": {
                    "value": "?has(owner,beer); .date(YY,MM,DD); .time(HH,NN,SS); +consumed(YY,MM,DD,HH,NN,SS,beer)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal has(owner,beer) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697130293,
    "message": {
      "type": "IntentionRemoved",
      "event": {
        "intentionInfo": {
          "id": 3,
          "state": "waiting",
          "intendedMeansInfo": []
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 3 removed , state: waiting"
    }
  },
  {
    "timestamp": 1694697130300,
    "message": {
      "type": "InternalActionFinished",
      "event": {
        "deedInfo": {
          "term": ".print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I)",
          "type": "internalAction",
          "srcInfo": "file:src/agt/robot.asl:45"
        },
        "intentionInfo": {
          "value": null
        }
      },
      "log": "Internal action .print(\"Failed to achieve goal \u0027!has(_,_)\u0027. Current intention is: \",I) finished"
    }
  },
  {
    "timestamp": 1694697130458,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 34
      },
      "log": "New reasoning cycle started: 34"
    }
  },
  {
    "timestamp": 1694697130718,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 35
      },
      "log": "New reasoning cycle started: 35"
    }
  },
  {
    "timestamp": 1694697131077,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 36
      },
      "log": "New reasoning cycle started: 36"
    }
  },
  {
    "timestamp": 1694697131483,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 37
      },
      "log": "New reasoning cycle started: 37"
    }
  },
  {
    "timestamp": 1694697131490,
    "message": {
      "type": "MailBoxMessages",
      "event": {
        "messages": [
          {
            "id": "samid3",
            "type": "askOne",
            "sender": "owner",
            "receiver": "robot",
            "message": "time(_26)"
          }
        ]
      },
      "log": "Messages in mailbox: \n\taskOne message from owner: time(_26)"
    }
  },
  {
    "timestamp": 1694697131495,
    "message": {
      "type": "SelectedMessage",
      "event": {
        "selected": {
          "id": "samid3",
          "type": "askOne",
          "sender": "owner",
          "receiver": "robot",
          "message": "time(_26)"
        }
      },
      "log": "Selected Message: time(_26)"
    }
  },
  {
    "timestamp": 1694697131500,
    "message": {
      "type": "NewSpeechActMessage",
      "event": {
        "message": {
          "id": "samid3",
          "type": "askOne",
          "sender": "owner",
          "receiver": "robot",
          "message": "time(_26)"
        }
      },
      "log": "New speech act message [askOne] from owner: time(_26)"
    }
  },
  {
    "timestamp": 1694697131505,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "kqml_received(owner,askOne,time(_26),samid3)",
          "source": {
            "value": null
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal kqml_received(owner,askOne,time(_26),samid3) created"
    }
  },
  {
    "timestamp": 1694697131510,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "kqml_received(owner,askOne,time(_26),samid3)",
        "planOptions": [
          {
            "label": "kqmlReceivedAskOne1c",
            "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
            "context": "",
            "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
          }
        ],
        "selectedPlan": {
          "label": "kqmlReceivedAskOne1c",
          "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
          "context": "",
          "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
        }
      },
      "log": "Plan options for kqml_received(owner,askOne,time(_26),samid3) are: \n\tkqml_received(Sender,askOne,NS::Content,MsgId) \u003c- .add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId).\nThe plan selected for kqml_received(owner,askOne,time(_26),samid3) is \tkqml_received(Sender,askOne,NS::Content,MsgId) \u003c- .add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)."
    }
  },
  {
    "timestamp": 1694697131516,
    "message": {
      "type": "PlanSelected",
      "event": {
        "goalInfo": {
          "goalFunctor": "kqml_received(owner,askOne,time(_26),samid3)",
          "source": {
            "value": null
          },
          "intention": {
            "value": null
          }
        },
        "goalStates": "executing",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Plan kqml_received(owner,askOne,time(_26),samid3) selected, state: executing"
    }
  },
  {
    "timestamp": 1694697131521,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "kqml_received",
              "type": "achieve",
              "plan": {
                "label": "kqmlReceivedAskOne1c",
                "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                "context": "",
                "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3}",
              "currentStep": {
                "value": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 kqml_received created, state: undefined\n\tcurrent step: .add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
    }
  },
  {
    "timestamp": 1694697131531,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "kqml_received",
              "type": "achieve",
              "plan": {
                "label": "kqmlReceivedAskOne1c",
                "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                "context": "",
                "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
              "currentStep": {
                "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 kqml_received created, state: undefined\n\tcurrent step: ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
    }
  },
  {
    "timestamp": 1694697131536,
    "message": {
      "type": "InternalActionFinished",
      "event": {
        "deedInfo": {
          "term": ".add_nested_source(Content,Sender,CA)",
          "type": "internalAction",
          "srcInfo": "kqmlPlans.asl:91"
        },
        "intentionInfo": {
          "value": {
            "id": 4,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "kqml_received",
                "type": "achieve",
                "plan": {
                  "label": "kqmlReceivedAskOne1c",
                  "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                  "context": "",
                  "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                },
                "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
                "currentStep": {
                  "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Internal action .add_nested_source(Content,Sender,CA) finished"
    }
  },
  {
    "timestamp": 1694697131542,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 38
      },
      "log": "New reasoning cycle started: 38"
    }
  },
  {
    "timestamp": 1694697131547,
    "message": {
      "type": "GoalCreated",
      "event": {
        "goalInfo": {
          "goalFunctor": "time(_74)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": {
              "id": 4,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "kqml_received",
                  "type": "achieve",
                  "plan": {
                    "label": "kqmlReceivedAskOne1c",
                    "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                    "context": "",
                    "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                  },
                  "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
                  "currentStep": {
                    "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "pending",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal time(_74) (sub-goal of kqml_received) created"
    }
  },
  {
    "timestamp": 1694697131553,
    "message": {
      "type": "ExecutedDeed",
      "event": {
        "deedInfo": {
          "term": "NS::CA",
          "type": "test",
          "srcInfo": "kqmlPlans.asl:92"
        },
        "intentionInfo": {
          "value": {
            "id": 4,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "kqml_received",
                "type": "achieve",
                "plan": {
                  "label": "kqmlReceivedAskOne1c",
                  "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                  "context": "",
                  "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                },
                "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
                "currentStep": {
                  "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Deed NS::CA of type test executed - from kqmlPlans.asl:92"
    }
  },
  {
    "timestamp": 1694697131559,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 39
      },
      "log": "New reasoning cycle started: 39"
    }
  },
  {
    "timestamp": 1694697131565,
    "message": {
      "type": "SelectPlanEvent",
      "event": {
        "event": "time(_74)[source(owner)]",
        "planOptions": [
          {
            "label": "p__10",
            "trigger": "time(T)",
            "context": "",
            "body": "time.check(T)"
          }
        ],
        "selectedPlan": {
          "label": "p__10",
          "trigger": "time(T)",
          "context": "",
          "body": "time.check(T)"
        }
      },
      "log": "Plan options for time(_74)[source(owner)] are: \n\ttime(T) \u003c- time.check(T).\nThe plan selected for time(_74)[source(owner)] is \ttime(T) \u003c- time.check(T)."
    }
  },
  {
    "timestamp": 1694697131571,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "time",
              "type": "test",
              "plan": {
                "label": "p__10",
                "trigger": "time(T)",
                "context": "",
                "body": "time.check(T)"
              },
              "unifier": "{T\u003d_74}",
              "currentStep": {
                "value": "time.check(T)"
              },
              "isFinished": false
            },
            {
              "trigger": "kqml_received",
              "type": "achieve",
              "plan": {
                "label": "kqmlReceivedAskOne1c",
                "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                "context": "",
                "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
              "currentStep": {
                "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 time created, state: undefined\n\tcurrent step: time.check(T)"
    }
  },
  {
    "timestamp": 1694697131591,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "time",
              "type": "test",
              "plan": {
                "label": "p__10",
                "trigger": "time(T)",
                "context": "",
                "body": "time.check(T)"
              },
              "unifier": "{T\u003d_74, _74\u003d\"15:12:11\"}",
              "currentStep": {
                "value": null
              },
              "isFinished": true
            },
            {
              "trigger": "kqml_received",
              "type": "achieve",
              "plan": {
                "label": "kqmlReceivedAskOne1c",
                "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                "context": "",
                "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
              "currentStep": {
                "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 time created, state: undefined\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697131597,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "time(_74)",
          "source": {
            "value": [
              "owner"
            ]
          },
          "intention": {
            "value": {
              "id": 4,
              "state": "undefined",
              "intendedMeansInfo": [
                {
                  "trigger": "kqml_received",
                  "type": "achieve",
                  "plan": {
                    "label": "kqmlReceivedAskOne1c",
                    "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                    "context": "",
                    "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                  },
                  "unifier": "{Sender\u003downer, NS\u003ddefault, Content\u003dtime(_26), MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
                  "currentStep": {
                    "value": "?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                  },
                  "isFinished": false
                }
              ]
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal time(_74) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697131604,
    "message": {
      "type": "InternalActionFinished",
      "event": {
        "deedInfo": {
          "term": "time.check(T)",
          "type": "internalAction",
          "srcInfo": "file:src/agt/robot.asl:68"
        },
        "intentionInfo": {
          "value": null
        }
      },
      "log": "Internal action time.check(T) finished"
    }
  },
  {
    "timestamp": 1694697131610,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 40
      },
      "log": "New reasoning cycle started: 40"
    }
  },
  {
    "timestamp": 1694697131616,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "kqml_received",
              "type": "achieve",
              "plan": {
                "label": "kqmlReceivedAskOne1c",
                "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                "context": "",
                "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "unifier": "{Sender\u003downer, _26\u003d\"15:12:11\", NS\u003ddefault, CA2\u003dtime(\"15:12:11\"), Content\u003dtime(_26), _74\u003d\"15:12:11\", MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
              "currentStep": {
                "value": ".send(Sender,tell,NS::CA2,MsgId)"
              },
              "isFinished": false
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 kqml_received created, state: undefined\n\tcurrent step: .send(Sender,tell,NS::CA2,MsgId)"
    }
  },
  {
    "timestamp": 1694697131622,
    "message": {
      "type": "InternalActionFinished",
      "event": {
        "deedInfo": {
          "term": ".remove_source_annot(CA,CA2)",
          "type": "internalAction",
          "srcInfo": "kqmlPlans.asl:94"
        },
        "intentionInfo": {
          "value": {
            "id": 4,
            "state": "undefined",
            "intendedMeansInfo": [
              {
                "trigger": "kqml_received",
                "type": "achieve",
                "plan": {
                  "label": "kqmlReceivedAskOne1c",
                  "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                  "context": "",
                  "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
                },
                "unifier": "{Sender\u003downer, _26\u003d\"15:12:11\", NS\u003ddefault, CA2\u003dtime(\"15:12:11\"), Content\u003dtime(_26), _74\u003d\"15:12:11\", MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
                "currentStep": {
                  "value": ".send(Sender,tell,NS::CA2,MsgId)"
                },
                "isFinished": false
              }
            ]
          }
        }
      },
      "log": "Internal action .remove_source_annot(CA,CA2) finished"
    }
  },
  {
    "timestamp": 1694697131630,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 41
      },
      "log": "New reasoning cycle started: 41"
    }
  },
  {
    "timestamp": 1694697131636,
    "message": {
      "type": "SendMessage",
      "event": {
        "messageInfo": {
          "id": "mid4",
          "type": "tell",
          "sender": "robot",
          "receiver": "owner",
          "message": "time(\"15:12:11\")"
        }
      },
      "log": "Send tell message to owner: time(\"15:12:11\")"
    }
  },
  {
    "timestamp": 1694697131644,
    "message": {
      "type": "IntentionCreated",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": [
            {
              "trigger": "kqml_received",
              "type": "achieve",
              "plan": {
                "label": "kqmlReceivedAskOne1c",
                "trigger": "kqml_received(Sender,askOne,NS::Content,MsgId)",
                "context": "",
                "body": ".add_nested_source(Content,Sender,CA); ?NS::CA; .remove_source_annot(CA,CA2); .send(Sender,tell,NS::CA2,MsgId)"
              },
              "unifier": "{Sender\u003downer, _26\u003d\"15:12:11\", NS\u003ddefault, CA2\u003dtime(\"15:12:11\"), Content\u003dtime(_26), _74\u003d\"15:12:11\", MsgId\u003dsamid3, CA\u003dtime(_26)[source(owner)]}",
              "currentStep": {
                "value": null
              },
              "isFinished": true
            }
          ]
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 kqml_received created, state: undefined\n\tcurrent step: finished"
    }
  },
  {
    "timestamp": 1694697131649,
    "message": {
      "type": "GoalRemoved",
      "event": {
        "result": "achieved",
        "goalInfo": {
          "goalFunctor": "kqml_received(owner,askOne,time(_26),samid3)",
          "source": {
            "value": null
          },
          "intention": {
            "value": {
              "id": 4,
              "state": "undefined",
              "intendedMeansInfo": []
            }
          }
        },
        "goalStates": "finished",
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Goal kqml_received(owner,askOne,time(_26),samid3) removed because the goal is achieved"
    }
  },
  {
    "timestamp": 1694697131658,
    "message": {
      "type": "IntentionRemoved",
      "event": {
        "intentionInfo": {
          "id": 4,
          "state": "undefined",
          "intendedMeansInfo": []
        },
        "reasonInfo": {
          "value": null
        }
      },
      "log": "Intention 4 removed , state: undefined"
    }
  },
  {
    "timestamp": 1694697131663,
    "message": {
      "type": "InternalActionFinished",
      "event": {
        "deedInfo": {
          "term": ".send(Sender,tell,NS::CA2,MsgId)",
          "type": "internalAction",
          "srcInfo": "kqmlPlans.asl:95"
        },
        "intentionInfo": {
          "value": null
        }
      },
      "log": "Internal action .send(Sender,tell,NS::CA2,MsgId) finished"
    }
  },
  {
    "timestamp": 1694697131820,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 42
      },
      "log": "New reasoning cycle started: 42"
    }
  },
  {
    "timestamp": 1694697132081,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 43
      },
      "log": "New reasoning cycle started: 43"
    }
  },
  {
    "timestamp": 1694697132437,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 44
      },
      "log": "New reasoning cycle started: 44"
    }
  },
  {
    "timestamp": 1694697132893,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 45
      },
      "log": "New reasoning cycle started: 45"
    }
  },
  {
    "timestamp": 1694697133452,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 46
      },
      "log": "New reasoning cycle started: 46"
    }
  },
  {
    "timestamp": 1694697134108,
    "message": {
      "type": "ReasoningCycleStarted",
      "event": {
        "cycleNumber": 47
      },
      "log": "New reasoning cycle started: 47"
    }
  }
]
